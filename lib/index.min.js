'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.initializeStore=initializeStore,exports.getStore=getStore,exports.updateStore=updateStore,exports.addObserver=addObserver;/** @format */var observers=[],store={},persistedStateKeys=null,persistStorage=null,persistTimeout=null;function initializeStore(a){if(a.persist!==void 0){// persist
var b={};// set the storage first
// get saved store from storage
// we should only save states that were restored
persistStorage=a.persist.storage,b=a.persist.restore(JSON.parse(persistStorage.getItem('fluxible-js'))||{}),persistedStateKeys=Object.keys(b),Object.keys(a.initialStore).forEach(function(c){store[c]=b[c]||a.initialStore[c]})}else Object.keys(a.initialStore).forEach(function(b){store[b]=a.initialStore[b]})}function getStore(){return store}function updateStore(a){null!==persistedStateKeys&&(null!==persistTimeout&&clearTimeout(persistTimeout),persistTimeout=setTimeout(function(){persistStorage.setItem('fluxible-js',JSON.stringify(persistedStateKeys.reduce(function(a,b){return a[b]=store[b],a},{})))},200));var b=Object.keys(a);// only notify observers that observes the store keys that were updated
b.forEach(function(b){store[b]=a[b]}),observers.forEach(function(c){// we want to maximize performance, so we loop as little as possible
if(b.length<c.wantedKeys.length){for(var d=0;d<b.length;d++)if(-1!==c.wantedKeys.indexOf(b[d])){c.callback(store);break}}else// they are either of the same length or
// the observer.wantedKeys is less than the updatedStateKeys
for(var a=0;a<c.wantedKeys.length;a++)if(-1!==b.indexOf(c.wantedKeys[a])){c.callback(store);break}})}function addObserver(a,b){var c={callback:a,wantedKeys:b,id:Math.random().toString()};return observers.push(c),function(){observers=observers.filter(function(a){return a.id!==c.id})}}